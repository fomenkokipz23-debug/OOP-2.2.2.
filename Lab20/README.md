# Лабораторна робота №20  
## Тема: SRP — декомпозиція класу `OrderProcessor`

###  Мета роботи
Застосувати **принцип єдиної відповідальності (SRP)** для рефакторингу складного класу `OrderProcessor` шляхом поділу його функціональності на менші, більш сфокусовані компоненти.

---

##  Завдання
1. **Створити початковий клас `OrderProcessor`**, який порушує SRP:
   - Перевіряє замовлення (`TotalAmount > 0`);
   - "Зберігає" замовлення (імітація - повідомлення у консоль);
   - Відправляє email-повідомлення (імітація - повідомлення у консоль);
   - Оновлює статус замовлення.

2. **Виконати рефакторинг**, щоб дотриматися SRP:
   - Виділити інтерфейси:
     ```csharp
     interface IOrderValidator
     interface IOrderRepository
     interface IEmailService
     ```
   - Створити їх реалізації:
     - `SimpleOrderValidator`
     - `InMemoryOrderRepository`
     - `ConsoleEmailService`
   - Створити клас **`OrderService`**, який координує роботу компонентів через **Dependency Injection**.

3. **Продемонструвати роботу в `Main`:**
   - Обробка валідного замовлення;
   - Обробка невалідного замовлення;
   - Вивід результатів у консоль.

---

##  Теоретичне обґрунтування
**SRP (Single Responsibility Principle)** - принцип єдиної відповідальності, згідно з яким  
*кожен клас повинен мати лише одну причину для зміни.*

Порушення SRP призводить до:
- складності в тестуванні;
- дублювання логіки;
- високої зв’язності коду.

Виконаний рефакторинг дозволяє розділити обов’язки між окремими класами:
| Компонент | Відповідальність |
|------------|------------------|
| `IOrderValidator` | Валідація замовлення |
| `IOrderRepository` | Збереження та отримання замовлень |
| `IEmailService` | Відправка повідомлень |
| `OrderService` | Координація компонентів (бізнес-логіка) |

---

