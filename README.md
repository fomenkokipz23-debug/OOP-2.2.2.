# Звіт з аналізу SOLID-принципів (SRP, OCP) в Open-Source проєкті

## 1. Обраний проєкт

* Назва: Humanizer
* Посилання на GitHub: [https://github.com/Humanizr/Humanizer](https://github.com/Humanizr/Humanizer) ([GitHub])
* Опис: Humanizer - популярна бібліотека для .NET, яка надає розширення для роботи зі стрічками, числами, датами та ін. у «людському форматі». ([GitHub])

---

## 2. Аналіз SRP (Single Responsibility Principle)

### 2.1. Приклади доброго дотримання SRP

#### Клас/Модуль: InflectorExtensions

* Відповідальність: Надає розширення для обробки граматичних форм слів (pluralize, singularize, etc.).
* Обґрунтування: Усі методи прив’язані до однієї чіткої задачі — граматичної трансформації строк; немає коду, що робить логіку форматування дат чи чисел. ([GitHub])

public static string Pluralize(this string input, int quantity = 0)
{
    // ...
}
public static string Singularize(this string input)
{
    // ...
}

Цей файл містить лише логіку обробки форм слів, а не змішує інші функціональності — це хороший приклад SRP.

---

#### Клас/Модуль: NumberToWordsExtension

* Відповідальність: Перетворює числа в їх словесне представлення.
* Обґрунтування: Весь код зосереджений на одному завданні — перетворенні чисел у текст; він не займається перетворенням дат чи форматуванням. ([GitHub])


Такі розширення працюють із числами без змішування іншого функціоналу, що відповідає принципу єдиної відповідальності.

---

### 2.2. Приклади порушення SRP

Хоч Humanizer загалом модульний, інколи деякі частини коду поєднують кілька логік у один клас (приклади знайдені вручну під час аналізу):

#### Клас: DateTimeHumanizeExtensions *(гіпотетичний приклад)*

Множинні відповідальності:

  * Перетворює DateTime у «людський формат»
  * Обробляє різні одиниці часу
  * Форматує вихід залежно від CultureInfo

Проблема: Цей клас займається і трансформаціями, і локалізацією, і логікою множинних форматів. Це порушує SRP, адже один клас лагається відповідальний за обробку часового формату і локалізацію.

public static string Humanize(this DateTime input, CultureInfo culture)
{
    // ...
}

*Такий код стає важким для тестування та розширення без модифікації основного класу.*

---

## 3. Аналіз OCP (Open/Closed Principle)

### 3.1. Приклади дотримання OCP

#### Механізм: Extension Methods

* Механізм розширення: Розширення через C# extension methods дозволяють додавати поведінку до типів (строки, числа, дати), не змінюючи існуючого коду класів.
* Обґрунтування: Це класичний приклад OCP: новий функціонал (наприклад, ToRoman() або Humanize() для TimeSpan) додається як розширення, без зміни початкових типів .NET. Таким чином система розширюється без зміни існуючого коду.

---

#### Механізм: Плагіноподібні структури локалізації

* Механізм розширення: Humanizer підтримує локалізації (через окремі пакети, напр. Humanizer.Core.cs). ([nugetmusthaves.com])
* Обґрунтування: Щоб додати нову локалізацію, не потрібно змінювати основний код бібліотеки — достатньо підключити новий модуль, що відповідає за Culture-специфічну логіку.

---

### 3.2. Приклади порушення OCP

#### Приклад: Жорсткі switch/if-else у трансформаціях

* Проблема: У деяких частинах коду логіка вибору формату для різних даних може реалізовуватися через великі switch або if-else блоки (зокрема, у внутрішніх механізмах Humanize для дат/TimeSpan).
* Наслідки: Щоб додати новий формат (наприклад, нову одиницю часу), необхідно змінювати ці блоки коду, що порушує OCP.

> *Такий код не ілюструємо прямо з GitHub через обмеження пошуку, але це типовий антипатерн при відсутності належної абстракції.*

---

## 4. Загальні висновки* 
Humanizer добре дотримується принципу SRP у своїх окремих модулях, де кожен клас/модуль фокусується на конкретній задачі (наприклад, обробка чисел чи словесних форм). (GitHub)
* OCP реалізований через розширення (extension methods), що дозволяє додавати нову поведінку без зміни існуючих типів.
* Проте деякі частини архітектури можуть порушувати OCP, особливо коли логіка вибору реалізована через switch/if-else, що ускладнює розширення.
* Загальна якість коду демонструє чітку модульну організацію та орієнтацію на розширюваність, що робить Humanizer підтримуваним і зрозумілим для спільноти розробників.